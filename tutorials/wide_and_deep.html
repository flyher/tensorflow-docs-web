<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>TensorFlow 宽深学习</title>
    <link href="//xitu.github.io/tensorflow-docs-web/assets/css/bootstrap.min.css" rel="stylesheet">
    <link href="//xitu.github.io/tensorflow-docs-web/assets/css/main.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
</head>
<body>
<!-- Header start -->
<nav class="navbar navbar-expand-lg navbar-light bg-light">
    <a class="navbar-brand" href="#">TensorFlow</a>
    <button class="navbar-toggler" type="button" aria-expanded="false" aria-label="Menu"
            onclick="$('.collapse').toggle()">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse">
        <ul class="navbar-nav mr-auto">
        </ul>
        <!-- TODO: Search function-->
        <!--<form class="form-inline my-2 my-lg-0">-->
            <!--<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search">-->
            <!--<button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>-->
        <!--</form>-->
    </div>
</nav>
<script>
    var head = [{'link': '//xitu.github.io/tensorflow-docs-web/extend/index.html', 'name': '扩展', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/install/index.html', 'name': '安装 TensorFlow', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/deploy/index.html', 'name': '部署', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/about/index.html', 'name': 'About TensorFlow', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/get_started/index.html', 'name': '开始', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/mobile/index.html', 'name': 'Overview', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/index.html', 'name': '教程', 'selected': 1}, {'link': '//xitu.github.io/tensorflow-docs-web/performance/index.html', 'name': '性能', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/community/index.html', 'name': 'Community', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/programmers_guide/index.html', 'name': '开发者指南', 'selected': 0}]
</script>
<!-- Header end -->

<!-- Content start-->
<div class="container-fluid">
    <div class="row">
        <nav class="col-md-2 d-none d-md-block bg-light sidebar">
    <div class="sidebar-sticky" id="left-nav">

    </div>
</nav>
<script>
    var nav = [{'type': 'child', 'link': '//xitu.github.io/tensorflow-docs-web/tutorials/index.html', 'title': '教程'}, {'type': 'parent', 'title': ' 图像', 'sub_class': [{'link': '//xitu.github.io/tensorflow-docs-web/tutorials/layers.html', 'title': 'TF Layers 教程：构建卷积神经网络'}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/image_recognition.html', 'title': '图像识别'}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/image_retraining.html', 'title': '重新训练 Inception 最后一层并识别新的分类'}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/deep_cnn.html', 'title': '卷积神经网络'}]}, {'type': 'parent', 'title': ' 序列', 'sub_class': [{'link': '//xitu.github.io/tensorflow-docs-web/tutorials/recurrent.html', 'title': '循环神经网络'}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/seq2seq.html', 'title': '序列到序列模型'}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/recurrent_quickdraw.html', 'title': '对涂鸦进行分类的循环神经网络'}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/audio_recognition.html', 'title': '简易语音识别'}]}, {'type': 'parent', 'title': ' 数据表示', 'sub_class': [{'link': '//xitu.github.io/tensorflow-docs-web/tutorials/wide.html', 'title': 'TensorFlow 线性模型'}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/wide_and_deep.html', 'title': 'TensorFlow 宽深学习'}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/word2vec.html', 'title': '单词的向量表示'}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/kernel_methods.html', 'title': '使用特定的核方法改善线性模型'}]}, {'type': 'parent', 'title': ' 非机器学习', 'sub_class': [{'link': '//xitu.github.io/tensorflow-docs-web/tutorials/mandelbrot.html', 'title': '曼德布洛特集合'}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/pdes.html', 'title': '偏微分方程组'}]}]
</script>
        <main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4">
            <h1>TensorFlow 宽深学习</h1>
<p><a href="//xitu.github.io/tensorflow-docs-web/./tutorials/wide.html">TensorFlow 线性模型</a></p>
<p>在本教程中，我们将介绍如何使用 tf.estimator API 来联合训练宽度线性模型和深度前馈神经网络。这种方法结合了记忆和泛化的优势。 它对于具有稀疏输入特征的一般大规模回归和分类问题（例如，具有大量可能特征值的类别型特征）很有用。如果您有兴趣详细了解宽深学习的工作原理，请参阅我们的<a href="https://arxiv.org/abs/1606.07792">研究论文</a>。</p>
<p><img src="../images/wide_n_deep.svg" alt="宽深学习模型示意图" title="Wide &amp; Deep"></p>
<p>上图展示了一个宽度模型（具有稀疏特征和变换的逻辑回归），深度模型（具有嵌入层和多个隐藏层的前馈神经网络）和宽深模型（两者的联合训练））。在较高的层面上，只需 3 个步骤即可使用 tf.estimator API 配置宽度，深度或宽深模型：</p>
<ol>
<li>为宽度部分选择特征：选择你想用的基本的稀疏特征列和交叉列。</li>
<li>为深度部分选择特征：选择连续列，每个类别列的嵌入维度以及隐藏层大小。</li>
<li>将他们放进一个宽深模型（<code>DNNLinearCombinedClassifier</code>）。</li>
</ol>
<p>就是这样！我们来看一个简单的例子。</p>
<h2>快速构建</h2>
<p>可以通过如下步骤尝试本教程的代码：</p>
<ol>
<li><a href="//xitu.github.io/tensorflow-docs-web/install/index.html">安装 TensorFlow</a></li>
<li>下载<a href="https://github.com/tensorflow/models/tree/master/official/wide_deep/">教程代码</a>.</li>
<li><p>执行我们提供的数据下载程序：</p>
<pre><code> $ python data_download.py
</code></pre>
</li>
<li><p>使用如下命令执行本教程的代码，训练一个教程中描述的宽深模型：</p>
<pre><code> $ python wide_deep.py
</code></pre>
</li>
</ol>
<p>继续阅读可以了解此代码是如何构建其模型的。</p>
<h2>定义基本特征列</h2>
<p>首先，我们定义将使用的基础类别型和连续型特征列。这些基础列将成为模型的宽度部分和深度部分使用的构建块。</p>
<pre><code class="lang-python">import tensorflow as tf

# 连续列
age = tf.feature_column.numeric_column(&#39;age&#39;)
education_num = tf.feature_column.numeric_column(&#39;education_num&#39;)
capital_gain = tf.feature_column.numeric_column(&#39;capital_gain&#39;)
capital_loss = tf.feature_column.numeric_column(&#39;capital_loss&#39;)
hours_per_week = tf.feature_column.numeric_column(&#39;hours_per_week&#39;)

education = tf.feature_column.categorical_column_with_vocabulary_list(
    &#39;education&#39;, [
        &#39;Bachelors&#39;, &#39;HS-grad&#39;, &#39;11th&#39;, &#39;Masters&#39;, &#39;9th&#39;, &#39;Some-college&#39;,
        &#39;Assoc-acdm&#39;, &#39;Assoc-voc&#39;, &#39;7th-8th&#39;, &#39;Doctorate&#39;, &#39;Prof-school&#39;,
        &#39;5th-6th&#39;, &#39;10th&#39;, &#39;1st-4th&#39;, &#39;Preschool&#39;, &#39;12th&#39;])

marital_status = tf.feature_column.categorical_column_with_vocabulary_list(
    &#39;marital_status&#39;, [
        &#39;Married-civ-spouse&#39;, &#39;Divorced&#39;, &#39;Married-spouse-absent&#39;,
        &#39;Never-married&#39;, &#39;Separated&#39;, &#39;Married-AF-spouse&#39;, &#39;Widowed&#39;])

relationship = tf.feature_column.categorical_column_with_vocabulary_list(
    &#39;relationship&#39;, [
        &#39;Husband&#39;, &#39;Not-in-family&#39;, &#39;Wife&#39;, &#39;Own-child&#39;, &#39;Unmarried&#39;,
        &#39;Other-relative&#39;])

workclass = tf.feature_column.categorical_column_with_vocabulary_list(
    &#39;workclass&#39;, [
        &#39;Self-emp-not-inc&#39;, &#39;Private&#39;, &#39;State-gov&#39;, &#39;Federal-gov&#39;,
        &#39;Local-gov&#39;, &#39;?&#39;, &#39;Self-emp-inc&#39;, &#39;Without-pay&#39;, &#39;Never-worked&#39;])

# 举个哈希的例子
occupation = tf.feature_column.categorical_column_with_hash_bucket(
    &#39;occupation&#39;, hash_bucket_size=1000)

# 转换
age_buckets = tf.feature_column.bucketized_column(
    age, boundaries=[18, 25, 30, 35, 40, 45, 50, 55, 60, 65])
</code></pre>
<h2>宽度模型：具有交叉特征列的线性模型</h2>
<p>宽度模型是一个线性模型，具有一系列稀疏和交叉的特征列：</p>
<pre><code class="lang-python">base_columns = [
    education, marital_status, relationship, workclass, occupation,
    age_buckets,
]

crossed_columns = [
    tf.feature_column.crossed_column(
        [&#39;education&#39;, &#39;occupation&#39;], hash_bucket_size=1000),
    tf.feature_column.crossed_column(
        [age_buckets, &#39;education&#39;, &#39;occupation&#39;], hash_bucket_size=1000),
]
</code></pre>
<p><a href="//xitu.github.io/tensorflow-docs-web/./tutorials/wide.html">TensorFlow 线性模型</a></p>
<p>具有交叉特征列的宽度模型可以有效记住特征之间的稀疏交互。话虽如此，交叉特征列的一个限制是它们不能推广到没有出现在训练数据中的特征组合。 让我们添加一个嵌入深层模型来解决这个问题。</p>
<h2>深层模型：带嵌入的神经网络</h2>
<p><a href="//xitu.github.io/tensorflow-docs-web/./tutorials/word2vec.html">单词的向量表示</a></p>
<p>另一种表达馈入神经网络的类别列的方法是通过 one-hot 或 multi-hot 表示。这通常适用于只有少数可能值的类别列。 作为 one-hot 表示的例子，对于 <code>relationship</code> 列，<code>"Husband"</code> 可以表示为 [1, 0, 0, 0, 0, 0]，并且可以将 <code>"Not-in-family"</code> 表示为[0, 1, 0, 0, 0, 0]等。这是一个固定的表示，而嵌入更加灵活并在训练时计算。</p>
<p>我们将使用 <code>embedding_column</code> 为类别列配置嵌入，并将它们与连续列连接起来。我们也使用 <code>indicator_column</code> 来创建一些类别列的 multi-hot 表示。</p>
<pre><code class="lang-python">deep_columns = [
    age,
    education_num,
    capital_gain,
    capital_loss,
    hours_per_week,
    tf.feature_column.indicator_column(workclass),
    tf.feature_column.indicator_column(education),
    tf.feature_column.indicator_column(marital_status),
    tf.feature_column.indicator_column(relationship),
    # To show an example of embedding
    tf.feature_column.embedding_column(occupation, dimension=8),
]
</code></pre>
<p>嵌入的“维数”越高，模型将必须学习的特征表示的自由度越高。为了简单起见，我们在此处为所有特征列设置维数为 8。 从经验上来说，关于维数的更明智的决定是以 \(\log_2(n)\) 或 \(k\sqrt[4]n\) 的顺序开始，其中 \(n\) 是特征列中唯一特征的数量，\(k\) 是一个小常量（通常小于 10）。</p>
<p>通过稠密嵌入，深度模型可以更好地泛化，并对之前在训练数据中看不到的特征对进行预测。然而，当两个特征列之间的基本交互矩阵是稀疏且高阶的时，很难学习特征列的有效低维表示。在这种情况下，大多数特征对之间的相互作用应该为零，除了少数特征对之间的相互作用之外，稠密嵌入将导致所有特征对的预测为非零，因此可能会过度泛化。另一方面，具有交叉特征的线性模型可以用较少的模型参数有效地记住这些“例外规则”。</p>
<p>现在，让我们看看如何共同训练宽深模型，并让它们互相补充优点和缺点。</p>
<h2>将宽深模型组合成一个模型</h2>
<p>宽度模型和深度模型通过将它们的最终输出的对数似然的和作为预测，然后将预测结果提供给对数损失函数。 所有的计算图定义和变量分配已经在你的框架底层处理过了，所以你只需要创建一个 <code>DNNLinearCombinedClassifier</code> ：</p>
<pre><code class="lang-python">model = tf.estimator.DNNLinearCombinedClassifier(
    model_dir=&#39;/tmp/census_model&#39;,
    linear_feature_columns=base_columns + crossed_columns,
    dnn_feature_columns=deep_columns,
    dnn_hidden_units=[100, 50])
</code></pre>
<h2>训练和评估模型</h2>
<p><a href="//xitu.github.io/tensorflow-docs-web/./tutorials/wide.html">TensorFlow 线性模型</a></p>
<p>读入数据之后，你可以训练和评估模型：</p>
<pre><code class="lang-python"># 每 `FLAGS.epochs_per_eval` 轮训练、评估一次模型。
for n in range(FLAGS.train_epochs // FLAGS.epochs_per_eval):
  model.train(input_fn=lambda: input_fn(
      FLAGS.train_data, FLAGS.epochs_per_eval, True, FLAGS.batch_size))

  results = model.evaluate(input_fn=lambda: input_fn(
      FLAGS.test_data, 1, False, FLAGS.batch_size))

  # 显示评估度量
  print(&#39;Results at epoch&#39;, (n + 1) * FLAGS.epochs_per_eval)
  print(&#39;-&#39; * 30)

  for key in sorted(results):
    print(&#39;%s: %s&#39; % (key, results[key]))
</code></pre>
<p>最终的输出精度应该在 85.5% 左右。 如果您希望看到一个可用的端到端示例，则可以下载我们的<a href="https://github.com/tensorflow/models/tree/master/official/wide_deep/wide_deep.py">样例代码</a>.</p>
<p>请注意，本教程只是一个小数据集的简单示例，可帮助你熟悉 API。如果你在具有大量可能特征值的稀疏特征列的大型数据集上进行试验，宽深学习功能将更加强大。再次说明，请随时查看我们的<a href="https://arxiv.org/abs/1606.07792">研究论文</a>，了解如何将宽深学习应用于实际的大型机器学习问题。</p>

        </main>
    </div>
</div>
<!-- Content end-->
</body>
<script src="//cdn.bootcss.com/jquery/3.3.1/jquery.slim.min.js" type="text/javascript"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js" type="text/javascript"></script>
<script src="//xitu.github.io/tensorflow-docs-web/assets/js/main.js" type="text/javascript"></script>
</html>