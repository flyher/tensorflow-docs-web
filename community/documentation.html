<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>编写 TensorFlow 文档</title>
    <link href="//xitu.github.io/tensorflow-docs-web/assets/css/bootstrap.min.css" rel="stylesheet">
    <link href="//xitu.github.io/tensorflow-docs-web/assets/css/main.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
</head>
<body>
<!-- Header start -->
<nav class="navbar navbar-expand-lg navbar-light bg-light">
    <a class="navbar-brand" href="#">TensorFlow</a>
    <button class="navbar-toggler" type="button" aria-expanded="false" aria-label="Menu"
            onclick="$('.collapse').toggle()">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse">
        <ul class="navbar-nav mr-auto">
        </ul>
        <!-- TODO: Search function-->
        <!--<form class="form-inline my-2 my-lg-0">-->
            <!--<input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search">-->
            <!--<button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>-->
        <!--</form>-->
    </div>
</nav>
<script>
    var head = [{'link': '//xitu.github.io/tensorflow-docs-web/extend/index.html', 'name': '扩展', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/install/index.html', 'name': '安装 TensorFlow', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/deploy/index.html', 'name': '部署', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/about/index.html', 'name': '关于 TensorFlow', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/get_started/index.html', 'name': '开始', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/mobile/index.html', 'name': '概述', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/tutorials/index.html', 'name': '教程', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/javascript/index.html', 'name': 'JavaScript', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/performance/index.html', 'name': '性能', 'selected': 0}, {'link': '//xitu.github.io/tensorflow-docs-web/community/index.html', 'name': '社区', 'selected': 1}, {'link': '//xitu.github.io/tensorflow-docs-web/programmers_guide/index.html', 'name': '开发者指南', 'selected': 0}]
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92630037-8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-92630037-8');
</script>

<!-- Header end -->

<!-- Content start-->
<div class="container-fluid">
    <div class="row">
        <nav class="col-md-2 d-none d-md-block bg-light sidebar">
    <div class="sidebar-sticky" id="left-nav">

    </div>
</nav>
<script>
    var nav = [{'type': 'child', 'link': '//xitu.github.io/tensorflow-docs-web/community/index.html', 'title': '社区'}, {'type': 'child', 'link': '//xitu.github.io/tensorflow-docs-web/community/roadmap.html', 'title': 'Roadmap'}, {'type': 'child', 'link': '//xitu.github.io/tensorflow-docs-web/community/contributing.html', 'title': '贡献 TensorFlow'}, {'type': 'child', 'link': '//xitu.github.io/tensorflow-docs-web/community/lists.html', 'title': 'Mailing Lists'}, {'type': 'child', 'link': '//xitu.github.io/tensorflow-docs-web/community/groups.html', 'title': '用户组织'}, {'type': 'child', 'link': '//xitu.github.io/tensorflow-docs-web/community/documentation.html', 'title': '编写 TensorFlow 文档'}, {'type': 'child', 'link': '//xitu.github.io/tensorflow-docs-web/community/style_guide.html', 'title': 'TensorFlow Style Guide'}, {'type': 'child', 'link': '//xitu.github.io/tensorflow-docs-web/community/benchmarks.html', 'title': '定义以及运行基准'}, {'type': 'child', 'link': '//xitu.github.io/tensorflow-docs-web/community/swift.html', 'title': 'Swift Community'}]
</script>
        <main role="main" class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content">
            <h1 id="toc-0">编写 TensorFlow 文档</h1>
<p>我们欢迎社区对 TensorFlow 文档做贡献。这份文档说明了你可以怎样为 TensorFlow 文档做出贡献，特别地，这份文档对以下内容进行了说明：</p>
<ul>
<li>文档位于什么地方。</li>
<li>怎样进行格式一致的编辑。</li>
<li>在提交之前，如何构建并测试你对文档做的改动。</li>
</ul>
<p>你可以在 <a href="https://www.tensorflow.org">https://www.tensorflow.org</a> 上查看 TensorFlow 文档，也可以查看并编辑它在 <a href="https://www.tensorflow.org/code/tensorflow/docs_src/">GitHub</a> 上的原始文件。我们正在将这些文档发布到 GitHub 上，以便每个人都可以为之做贡献。所有经过核对编入 <code>tensorflow/docs_src</code> 的内容之后都会尽快地发布到 <a href="https://www.tensorflow.org">https://www.tensorflow.org</a>。</p>
<p>我们非常欢迎通过不同的形式重新发布 TensorFlow 文档，但我们不大可能允许让别的格式的文档（或者其他的文档生成工具）进入我们的代码仓库。如果你想以另外的格式重新发布我们的文档，请确保包含以下内容：</p>
<ul>
<li>这种格式的文档对应的 API 版本（例如 r1.0、master 等等）</li>
<li>这份文档是从哪次提交或者哪个版本产生的</li>
<li>从哪里（即 <a href="https://www.tensorflow.org）可以找到最新版本的文档">https://www.tensorflow.org）可以找到最新版本的文档</a></li>
<li>Apache 2.0 开源许可协议</li>
</ul>
<h2 id="toc-1">关于版本的说明</h2>
<p>在 tensorflow.org 网站的根目录下有针对 Tensorflow 最新的稳定版二进制文档。如果你在用 <code>pip</code> 命令来安装 TensorFlow，你应该阅读这份文档。</p>
<p>但是，大多数的开发者都是向 GitHub 的 master 分支里的文档做贡献，这份文档会在 <a href="https://www.tensorflow.org/versions/master">tensorflow.org/versions/master</a> 不定时地发布。</p>
<p>如果你想对出现在网站的根目录中的文档做一些改动，你需要将文档的变动提交到当前的稳定版二进制分支（和/或 <a href="https://stackoverflow.com/questions/9339429/what-does-cherry-picking-a-commit-with-git-mean">cherrypick</a> 分支）。</p>
<h2 id="toc-2">参考文档与非参考文档</h2>
<p>下面的 reference documentation 是由代码中的注释自动生成的：</p>
<ul>
<li>C++ API 参考文档</li>
<li>Java API 参考文档</li>
<li>Python API 参考文档</li>
</ul>
<p>如果想修改参考文档，你需要编辑对应的代码注释。</p>
<p>非参考文档（例如 TensorFlow 的安装指南）是由人们撰写的。</p>
<p>这份文档位于 <a href="https://www.tensorflow.org/code/tensorflow/docs_src/"><code>tensorflow/docs_src</code></a> 目录。<code>docs_src</code> 的每个子目录下包含一系列相关 TensorFlow 文档。例如，TensorFlow 的安装指南全部位于 <code>docs_src/install</code> 目录中。</p>
<p>C++ 文档是通过文档生成工具从 XML 文件生成的；但是这些工具现在还没有开源。</p>
<h2 id="toc-3">Markdown</h2>
<p>可编辑的 TensorFlow 文档都是用 Markdown 编写的。除了一些例外的情况，TensorFlow 使用<a href="https://daringfireball.net/projects/markdown/">标准 Markdown 语法规则</a>。</p>
<p>这一节介绍标准 Markdown 语法规则和可编辑的 TensorFlow 文档中使用的 Markdown 语法规则之间的主要差异。</p>
<h3 id="toc-4">Markdown 中的数学公式</h3>
<p>在编辑 Markdown 文件时，你可以在 TensorFlow 中使用 MathJax，但是需要注意以下几点：</p>
<ul>
<li>MathJax 可以在 <a href="https://www.tensorflow.org">tensorflow.org</a> 上正确地渲染</li>
<li>MathJax 不能在 <a href="https://github.com/tensorflow/tensorflow">github</a> 上正确地渲染</li>
</ul>
<p>在写 MathJax 的时候，你可以使用 <code>&#36;&#36;</code> 和 <code>\\(</code>、<code>\\)</code> 将数学公式包起来。<code>&#36;&#36;</code> 会导致会换行，所以在文本行内使用 <code>\\(</code>、<code>\\)</code>。</p>
<h3 id="toc-5">Markdown 中的链接</h3>
<p>链接可以分为几种类型：</p>
<ul>
<li>指向同一文件中不同部分的链接</li>
<li>指向 tensorflow.org 网站外其他 URL 地址的链接</li>
<li>从一个 Markdown 文件 (或者代码注释) 指向 tensorflow.org 网站内其他文件的链接。</li>
</ul>
<p>对于前两种链接类型，你可以使用标准的 Markdown 链接，但要把链接全部都放在一行，而不是把它拆分成多行。例如：</p>
<ul>
<li><code>[text](link)    # 好的链接</code></li>
<li><code>[text]\n(link)  # 不好的链接</code></li>
<li><code>[text](\nlink)  # 不好的链接</code></li>
</ul>
<p>对于最后一种类型的链接（指向 tensorflow.org 网站内其他文件的链接），请使用一种特殊的链接参数化机制，以使作者不改动链接也能移动和重新组织文件。</p>
<p>这种参数化机制具体如下，使用：</p>
<p><!-- 注意：t&#64; 的使用是一种 hack，所以我们没有把它转换成符号 --></p>
<ul>
<li><p><code>&#64;{tf.symbol}</code> 链接到 Python 符号参考页面。需要注意，类成员没有自己的页面，但是这种语法仍然奏效，因为 <code>&#64;{tf.MyClass.method}</code> 会链接到 <code>tf.MyClass</code> 页面合适的部分。</p>
</li>
<li><p><code>&#64;{tensorflow::symbol}</code> 链接到 C++ 符号页面。</p>
</li>
<li><p><code>&#64;{$doc_page}</code> 链接到另一个文档页面（非 API 参考）。为了链接到</p>
<ul>
<li><p><code>red/green/blue/index.md</code>，使用 <code>&#64;{$blue}</code> 或者 <code>&#64;{$green/blue}</code>，</p>
</li>
<li><p><code>foo/bar/baz.md</code>，使用 <code>&#64;{$baz}</code> 或者 <code>&#64;{$bar/baz}</code>。</p>
<p>应该首选较短的这个，这样我们就可以在不破坏这些引用的情况下移动页面。主要的例外是 Python API 指南应该使用 <code>&#64;{$python/<guide-name>}</code> 引用以避免产生歧义。</p>
</li>
</ul>
</li>
<li><p><code>&#64;{$doc_page#anchor-tag$link-text}</code> 链接到该文档的另一个链接标记并使用不同的链接文本（在默认情况下，链接文本是目标页面的标题）。</p>
<p>如果只要重写链接文本，可以忽略 <code>#anchor-tag</code>。</p>
</li>
</ul>
<p>如果要链接到源代码，使用以 <code>https://www.tensorflow.org/code/</code> 开头的链接，然后跟上它在 github 根目录下的文件名。例如，你现在正在读的这个文件的链接应该写作 <code>https://www.tensorflow.org/code/tensorflow/docs_src/community/documentation.md</code>。</p>
<p>这种 URL 的命名方式可以确保 <a href="https://www.tensorflow.org/">tensorflow.org</a> 能够将链接转到你正在阅读的相应版本文档的代码。一定不要在源代码的 URL 中添加链接参数。</p>
<h2 id="toc-6">生成文档和预览链接</h2>
<p>在构建文档之前，你必须先完成以下步骤来安装环境：</p>
<ol>
<li><p>如果你的机器没有安装 bazel，现在就装上它。如果你用的是 Linux，使用下面的命令来安装 bazel：</p>
<pre><code> $ sudo apt-get install bazel  # Linux
</code></pre>
<p>如果你用的是 Mac OS, 可以去<a href="https://bazel.build/versions/master/docs/install.html#mac-os-x">这个页面</a> 找 bazel 的安装说明。</p>
</li>
<li><p>切换至 TensorFlow 源代码中 <code>tensorflow</code> 文件夹所在的目录。</p>
</li>
<li><p>运行 <code>configure</code> 脚本，按照提示，根据你的系统选择合适的指令。</p>
<pre><code> $ ./configure
</code></pre>
</li>
</ol>
<p>然后，切换到包含 <code>docs_src</code> 的 <code>tensorflow</code> 目录 (<code>cd tensorflow</code>)。运行下面的命令来编译 TensorFlow 并在 <code>/tmp/tfdocs</code> 目录中生成文档：</p>
<pre><code>bazel run tools/docs:generate -- \
          --src_dir="$(pwd)/docs_src/" \
          --output_dir=/tmp/tfdocs/
</code></pre>
<p>注意：你必须将 <code>src_dir</code> 和 <code>output_dir</code> 设置为绝对文件路径。</p>
<h2 id="toc-7">生成 Python API 文档</h2>
<p>操作 (op)、类 (class)、功能函数 (utility functions) 都是在 Python 模块中定义的，例如 <code>image_ops.py</code>。Python 中模块都包含一个模块文档字符串。例如：</p>
<pre><code class="lang-python">&quot;&quot;&quot;Image processing and decoding ops.&quot;&quot;&quot;
</code></pre>
<p>文档生成器会把模块文档字符串放在针对该模块生成的 Markdown 文件的开头，在这个例子中就是 <a href="https://www.tensorflow.org/api_docs/python/tf/image">tf.image</a>。</p>
<p>有时候需要在模块文件的开头列出一个模块的所有成员，这时可以在每个成员前添加 <code>@@</code>。<code>@@member_name</code> 语法已经被废弃了，不会生成任何文档。但是根据模块的<a href="#密封模块">密封方式</a>，有可能需要将一个模块的内容元素标记为公开的。被调用的操作（op）、函数（function）或类（class）不必在同一个文件中进行定义。本文档接下来的几个部分将讨论密封以及如何向公共文档添加元素。</p>
<p>新的文档系统会自动记录公共符号，但不包括下面这些：</p>
<ul>
<li>以下划线开头的私有符号。</li>
<li><code>object</code> 中原本定义的符号或 protobuf 的 <code>Message</code>。</li>
<li>一些类的成员，例如被动态创建但通常有没有有用的文档的 <code>__base__</code>、<code>__class__</code>。</li>
</ul>
<p>只有上层模块（目前只有 <code>tf</code> 和 <code>tfdbg</code>）需要被手动添加到生成脚本中。</p>
<h3 id="toc-8">密封模块</h3>
<p>因为文档生成器会遍历所有可见的符号，并深入它能找到的任何东西，所以它会记录意外暴露出来的符号。如果一个模块只会暴露那些有意作为开放 API 的一部分的符号，我们就称其为<strong>密封的</strong>。由于 Python 有宽松的导包机制和可见性的传统，那些写得很幼稚的 Python 代码会无意中暴露出很多实现细节的模块。密封不合理的模块可能会暴露出其他没有封装好的模块，这往往会导致文档生成器生成失败。<strong>这种失败是符合预期的行为。</strong> 它确保我们的 API 定义良好，并允许我们无需担心意外中断用户，就能更改实施细节（包括哪些模块被导入到哪里）。</p>
<p>如果一个模块被意外导入了，它通常会中断文档生成器(<code>generate_test</code>)。这是你需要密封你的模块的一个明显标志。然而即使文档成功生成了，其中也可能会出现一些不需要的符号。检查生成的文档以确保所有被记录的符号都是符合预期的。如果一个地方出现了不该出现的符号，你有下面几个选项可以对它们进行处理：</p>
<ul>
<li>私有符号和导入</li>
<li><code>remove_undocumented</code> 过滤器</li>
<li>一个可遍历的黑名单。</li>
</ul>
<p>下面我们会详细地讨论这些选项。</p>
<h4 id="toc-9">私有符号和导入</h4>
<p>使 API 密封符合要求的最简单的方法就是将非公开的符号私有化（通过预先加下划线 <code>_</code>）。文档生成器会遵守私有符号，这同样也适用于模块。如果唯一的问题是文档中显示少量导入的模块（或打破了生成器），你可以简单地在导入时重命名它们，例如：<code>import sys as _sys</code>。</p>
<p>因为 Python 会将所有的文件视为模块，所以这也适用与文件。如果你的文件中包含下面两个文件/模块：</p>
<pre><code>module/__init__.py
module/private_impl.py
</code></pre>
<p>在 <code>module</code> 被导入之后，有可能可以访问 <code>module.private_implit</code>。将 <code>private_impl.py</code> 重命名为 <code>_private_impl.py</code> 可以解决这个问题。如果重命名模块比较尴尬，请继续阅读。</p>
<h4 id="toc-10">使用 <code>remove_undocumented</code> 过滤器</h4>
<p>密封模块的另一种方式是从 API 中拆分出来你的实现。为此，请考虑使用 <code>remove_undocumented</code>，其中包含允许的符号列表，并从模块中删除其他所有内容。例如，以下代码段演示了如何将 <code>remove_undocumented</code> 一个模块的 <code>__init__.py</code> 文件中：</p>
<p><strong>init</strong>.py:</p>
<h1 id="toc-11">只有在定义了 <code>__all__</code> 的文件中使用 <code>*</code> 导入</h1>
<pre><code>from tensorflow.some_module.some_file import *

# 否则就直接导入符号
from tensorflow.some_module.some_other_file import some_symbol

from tensorflow.python.util.all_util import remove_undocumented

_allowed_symbols = [‘some_symbol’, ‘some_other_symbol’]

remove_undocumented(__name__, allowed_exception_list=_allowed_symbols)
</code></pre>
<p>该 <code>@@member_name</code> 语法已经被废弃了，但它仍然作为 <code>remove_undocumented</code> 的指示器在文档中的某些地方存在，用于指示这些符号是公开的。所有的 <code>@@</code> 最终都将被删除。但是，如果你看到它们，请不要随意删除，因为我们的某些系统仍在使用它们。</p>
<h4 id="toc-12">遍历黑名单</h4>
<p>如果上述的方法都失败了，你可以在遍历黑名单中添加条目 <code>generate_lib.py</code>。<strong>这个列表中几乎所有的条目都是对它存在的目的的一种滥用；尽量避免向这个列表中添加东西。</strong></p>
<p>遍历黑名单将合法的模块名称（不带前缀 <code>tf.</code>）映射到不向下遍历到的局部名称。例如，以下条目将从遍历中排除 <code>some_module</code>。</p>
<pre><code>{ ...
  ‘contrib.my_module’: [‘some_module’]
  ...
}
</code></pre>
<p>这意味着文档生成器将显示 <code>some_module</code> 存在，但它不会枚举其内容。</p>
<p>这个黑名单最初是为了确保用于平台抽象的系统模块（mocks、flags 等等）可以被记录下来，而无需记录其内部空间。对于 contrib 而言，它超出此目的的用途是一个可以接受的捷径，但对于 core tensorflow 来说并不是。</p>
<h2 id="toc-13">操作（op）文档样式指南</h2>
<p>关于模块的很长的、描述性模块级文档应该在 <code>docs_src/api_guides/python</code> 的 API 指南中。</p>
<p>在理想情况下，对于类（class）和操作（op），你应该按照演示的顺序，提供以下信息：</p>
<ul>
<li>一个描述操作（op）作用的简短的句子。</li>
<li>一个关于当传递参数给操作（op）时会发生什么的简短描述。</li>
<li>一个显示操作（op）如何工作的示例（最好有伪代码）。</li>
<li>要求、注意事项、重要说明（如果有的话）。</li>
<li>对操作（op）构造函数的输入、输出、Attrs 或其他参数的描述。</li>
</ul>
<p>每一项都在<a href="#文档字符串章节的描述">下面</a>有更详细的描述。</p>
<p>用 Markdown 来写。基本语法参考在<a href="https://daringfireball.net/projects/markdown/">这里</a>。你可以使用 <a href="https://www.mathjax.org">MathJax</a> 符号来写公式（见上文有关限制）。</p>
<h3 id="toc-14">关于代码的写法</h3>
<p>下面这些东西用于文本中间时需要用反单引号包起来：</p>
<ul>
<li>参数名（例如 <code>input</code>、<code>x</code>、<code>tensor</code>）</li>
<li>返回的张量名（例如 <code>output</code>、<code>idx</code>、<code>out</code>）</li>
<li>数据类型（例如 <code>int32</code>、<code>float</code>、<code>uint8</code>）</li>
<li>文本中引用的其他操作（op）名（例如 <code>list_diff()</code>、<code>shuffle()</code>）</li>
<li><p>类（class）名（例如使用 <code>Tensor</code>，实际上你用它来表示一个 <code>Tensor</code> 对象；如果你只是要解释一个操作（op）要对一个张量、一幅图做什么，或者是要解释某种一般的操作，不要大写或使用反单引号。</p>
</li>
<li><p>文件名（例如 <code>image_ops.py</code> 或 <code>/path-to-your-data/xml/example-name</code>）</p>
</li>
<li>数学表达式或条件（例如 <code>-1-input.dims() &lt;= dim &lt;= input.dims()</code>）</li>
</ul>
<p>用三个反单引号样例代码和伪代码示例包起来。还要用 <code>==&gt;</code> 而不是一个等号用于表示一个操作（op）返回什么。例如：</p>
<pre><code>    # 'input' 是形状为 [2, 3, 5] 的一个张量
    (tf.expand_dims(input, 0)) ==&gt; [1, 2, 3, 5]
</code></pre>
<p>如果你要提供一个 Python 的示例代码，添加 Python 风格标签以确保完成合适的语法高亮：</p>
<pre><code class="lang-python">    # 一些 Python 代码
</code></pre>
<p>Markdown 中关于示例代码反单引号的两点说明：</p>
<ol>
<li><p>如果有必要的话，你可以使用反单引号来美观地显示除 Python 外的其他语言，<a href="https://github.com/google/code-prettify#how-do-i-specify-the-language-of-my-code">这里</a>有一份可用语言的完整列表。</p>
</li>
<li><p>Markdown 也允许你使用四个空格的缩进来指示一段代码示例。但是，一定不要同时使用四个空格缩进和反单引号，只使用其中之一。</p>
</li>
</ol>
<h3 id="toc-15">张量维度</h3>
<p>当你在谈论一般的张量（tensor）时，不要大写这个词的首字母。当你在谈论作为参数提供给操作（op）或由操作（op）返回的特定对象时，你应该使用 Tensor 这个词，并在其周围添加反单引号，因为你在谈论一个 <code>Tensor</code> 对象。</p>
<p>不要使用 <code>Tensors</code> 这个词来表示多个 Tensor 对象，除非你真的在谈论一个 <code>Tensors</code> 对象。更好的说法是“许多 <code>Tensor</code> 对象（a list of <code>Tensor</code> objects）。</p>
<p>使用术语“维度”来表示张量的大小。如果您需要指定具体的大小，请使用以下约定：</p>
<ul>
<li>标量表示“0 维张量”</li>
<li>向量表示“1 维张量”</li>
<li>矩阵表示“2 维张量”</li>
<li>张量表示“3 维张量”或“n 维张量”。“秩”这个词真正有用的时候再用，不然就用维度。永远不要用“阶数”这个词来描述张量的大小。</li>
</ul>
<p>使用“形状”这个词来具体说明张量的维度，并用一对方括号来展示一个张量的形状。例如：</p>
<pre><code>如果 `input` 是一个形状为 `[3, 4, 3]` 的三维张量，
这个操作会返回一个形状为 `[6, 8, 6]` 的三维张量。
</code></pre>
<h3 id="toc-16">C++ 中定义的操作（op）</h3>
<p>所有在 C++ 中定义的操作（并且可以通过其他语言访问）必须用 <code>REGISTER_OP</code> 声明来记录。C++ 文件中的文档字符串经过处理会自动为输入类型、输出类型和 Attr 类型以及默认值添加一些信息。</p>
<p>例如：</p>
<pre><code class="lang-c++">    REGISTER_OP(&quot;PngDecode&quot;)
      .Input(&quot;contents: string&quot;)
      .Attr(&quot;channels: int = 0&quot;)
      .Output(&quot;image: uint8&quot;)
      .Doc(R&quot;doc(
    Decodes the contents of a PNG file into a uint8 tensor.

    contents: PNG file contents.
    channels: Number of color channels, or 0 to autodetect based on the input.
      Must be 0 for autodetect, 1 for grayscale, 3 for RGB, or 4 for RGBA.
      If the input has a different number of channels, it will be transformed
      accordingly.
    image:= A 3-D uint8 tensor of shape `[height, width, channels]`.
      If `channels` is 0, the last dimension is determined
      from the png contents.
    )doc&quot;);
</code></pre>
<p>会输出下面的 Markdown 结果：</p>
<h3 id="toc-17">tf.image.png_decode(contents, channels=None, name=None) {#png_decode}</h3>
<pre><code>Decodes the contents of a PNG file into a uint8 tensor.

#### Args:

*  &lt;b&gt;contents&lt;/b&gt;: A string Tensor. PNG file contents.
*  &lt;b&gt;channels&lt;/b&gt;: An optional int. Defaults to 0.
   Number of color channels, or 0 to autodetect based on the input.
   Must be 0 for autodetect, 1 for grayscale, 3 for RGB, or 4 for RGBA.  If the
   input has a different number of channels, it will be transformed accordingly.
*  &lt;b&gt;name&lt;/b&gt;: A name for the operation (optional).

#### Returns:
A 3-D uint8 tensor of shape `[height, width, channels]`.  If `channels` is
0, the last dimension is determined from the png contents.
</code></pre>
<p>大多数的参数描述都是被自动添加的。特别的是，文档生成器会自动为所有的输入、属性和输出添加名称和类型。在上面的例子中，<code>&lt;b&gt;contents&lt;/b&gt;: A string Tensor.</code> 是被自动添加的。你应该在那个描述之后多写点额外的文字让它顺畅自然一些。</p>
<p>对于输入和输出，你可以在额外的文字前加等号来避免自动添加名称和类型。在上面的例子中，名称为 <code>image</code> 的输出描述以 <code>=</code> 开头以避免在文字 <code>A 3-D uint8 Tensor...</code> 前添加 <code>A uint8 Tensor.</code>。你不能通过这种方式来避免添加属性的名称、类型和默认值，所以要小心写这些文本。</p>
<h3 id="toc-18">Python 中定义的操作（op）</h3>
<p>如果你的操作（op）是在 <code>python/ops/*.py</code> 文件中定义的，则需要为所有参数和输出（返回值）张量提供文本。文档成器不会自动生成 Python 中定义的操作（op）的任何文本，所以你写什么就会得到什么。</p>
<p>你应该遵守常见的 Python 文档字符串约定，但您应该在文档字符串中使用 Markdown 语法格式。</p>
<p>这是一个简单的例子：</p>
<pre><code>def foo(x, y, name="bar"):
  """计算 foo 函数。

  给定两个一维张量 `x` 和 `y`，这个操作会计算 foo 函数。

  示例：

  ```
  # x 的形状是 [1, 1]
  # y 的形状是 [2, 2]
  tf.foo(x, y) ==&gt; [3, 3]
  ```
  参数：
    x: 一个 `int32` 类型的 `Tensor`。
    y: 一个 `int32` 类型的 `Tensor`。
    name: 操作的名字（可选）。

  返回值：
    一个 `int32` 类型的 `Tensor`，是 `x` 和 `y` 的 foo 函数值
</code></pre>
<p>     错误引发：<br>
        ValueError: If <code>x</code> or <code>y</code> are not of type <code>int32</code>.<br>
      """</p>
<h2 id="toc-19">文档字符串章节的描述</h2>
<p>这一节会详细介绍文档字符串中的每个元素。</p>
<h3 id="toc-20">描述操作（op）是做什么的短句</h3>
<p>示例：</p>
<pre><code>连接张量。
</code></pre>
<pre><code>从左向右水平翻转一幅图像。
</code></pre>
<pre><code>计算两个序列之间的 Levenshtein 距离。
</code></pre>
<pre><code>将一些张量保存到一个文件中。
</code></pre>
<pre><code>从一个张量中提取一些切片。
</code></pre>
<h3 id="toc-21">对传递参数给这个操作（op）后会发生什么的简要描述</h3>
<p>示例：</p>
<pre><code>给定一个数值类型的张量输入，这个操作会返回一个相同类型和大小但是值会按照 `seq_dim` 维度逆序的张量。向量 `seq_lengths` 确定维度 0（通常是 batch 对应的维度）内的每个索引都逆序了哪些元素。
</code></pre>
<p>   这一操作会返回一个类型为 <code>dtype</code>，维度为 <code>shape</code> 的张量，并且所有的元素都被置为 0。</p>
<h3 id="toc-22">对操作（op）举例说明</h3>
<p>好的代码示例很简单，易于理解，通常包含一个简短的代码段用以阐明示例在说明什么。当操作（op）是对一个 Tensor 的形状进行操作时，在示例中包含操作前和操作后往往也是有用的。</p>
<p><code>squeeze()</code> 操作有一个非常好的伪代码示例：</p>
<h1 id="toc-23">'t' 是一个形状为 [1, 2, 1, 3, 1, 1] 的张量</h1>
<pre><code>shape(squeeze(t)) ==&gt; [2, 3]
</code></pre>
<p><code>tile()</code> 操作在描述性文本方面提供了一个很好的样例：</p>
<pre><code>例如，用 `[2]` 对 `[a, b, c, d]` 进行 `tile()` 操作会产生 `[a b c d a b c d]`。
</code></pre>
<p>最好使用 Python 来展示示例代码。永远不要将它们放到 C++ 的操作文件中，并且也要避免将它们放到 Python 的操作文档中。我们推荐尽可能地将代码示例放到 <a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/docs_src/api_guides">API 指南</a>。否则，将它们添加到调用操作构造函数的模块或者类的文档字符串中。</p>
<p>在 <code>api_guides/python/math_ops.md</code> 有一个模块文档字符串的例子：</p>
<h2 id="toc-24">分割</h2>
<pre><code>TensorFlow 有多种操作方式供你执行数学运算和张量分割。
...
特别地，对矩阵张量的分割操作是一个矩阵的各行到分割片段的映射。


例如：

```python
c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])
tf.segment_sum(c, tf.constant([0, 0, 1]))
  ==&gt;  [[0 0 0 0]
        [5 6 7 8]]
```
</code></pre>
<h3 id="toc-25">要求、注意事项、重要说明</h3>
<p>示例：</p>
<pre><code>这个操作要求 `-1-input.dims() &lt;= dim &lt;= input.dims()`
</code></pre>
<pre><code>说明：如果对这个张量求值会产生错误。它的值必须使用 `Session.run()`、`Tensor.eval()` 或 `Operation.run()` 的可选参数 `feed_dict` 导入 。
</code></pre>
<h3 id="toc-26">对参数和输出（返回）张量的描述</h3>
<p>要保证描述言简意赅。不应该在参数部分介绍这个操作是如何工作的。</p>
<p>如果这个操作对输入张量或输出张量的维度有很强的限制，这里就应该提及。请记住，对于 C++ 操作，张量的类型是自动添加的，为 "A ..type .. Tensor" 或“A 类型在 {...list of types...}”。在这种情况下，如果操作对张量的维度有约束，则可以添加诸如“必须为 4 维”的文本，或者用 <code>=</code>（为了防止添加张量类型）开始描述，例如写上“一个 4 维的 float 张量”。</p>
<p>例如，这里有两种方式来对一个 C++ 操作中 image 参数进行记录（注意符号“=”）：</p>
<pre><code>image: 必须为 4 维。要调整尺寸的图像。
</code></pre>
<pre><code>image:= 一个 4 维的 `float` 型张量。要调整尺寸的图像。
</code></pre>
<p>在文档中，这些会被渲染成如下所示的 Markdown 格式</p>
<pre><code>image: 一个 `float` 型张量。必须为 4 维。要调整尺寸的图像。
</code></pre>
<pre><code>image: 一个 4 维的 `float` 型张量。要调整尺寸的图像。
</code></pre>
<h3 id="toc-27">可选参数说明（“attrs”）</h3>
<p>文档生成器总会描述每个 attr 的类型及其默认值（如果有的话）。由于 C++ 和 Python 生成的文档的描述是非常不同的，因此您不能使用等号来覆盖它。</p>
<p>对任何额外的 attr 描述选择合理的措辞，以便在类型和默认值之后能够读得流畅。首先展示类型和默认值，后面是附加说明。因此，完整的句子是最好的。</p>
<p>这里有一个 <code>image_ops.cc</code> 中的例子：</p>
<pre><code>REGISTER_OP("DecodePng")
    .Input("contents: string")
    .Attr("channels: int = 0")
    .Attr("dtype: {uint8, uint16} = DT_UINT8")
    .Output("image: dtype")
    .SetShapeFn(DecodeImageShapeFn)
    .Doc(R"doc(
Decode a PNG-encoded image to a uint8 or uint16 tensor.

The attr `channels` indicates the desired number of color channels for the
decoded image.

Accepted values are:

*   0: Use the number of channels in the PNG-encoded image.
*   1: output a grayscale image.
*   3: output an RGB image.
*   4: output an RGBA image.

If needed, the PNG-encoded image is transformed to match the requested
number of color channels.

contents: 0-D.  The PNG-encoded image.
channels: Number of color channels for the decoded image.
image: 3-D with shape `[height, width, channels]`.
)doc");
</code></pre>
<p>这将在 <code>api_docs/python/tf/image/decode_png.md</code> 中生成下面的 Args 部分：</p>
<h4 id="toc-28">Args:</h4>
<ul>
<li><b>`contents`</b>: A <code>Tensor</code> of type <code>string</code>. 0-D.  The PNG-encoded<br>
image.</li>
<li><b>`channels`</b>: An optional <code>int</code>. Defaults to <code>0</code>. Number of color<br>
channels for the decoded image.</li>
<li><b>`dtype`</b>: An optional <code>tf.DType</code> from: <code>tf.uint8,
tf.uint16</code>. Defaults to <code>tf.uint 8</code>.</li>
<li><b>`name`</b>: A name for the operation (optional).</li>
</ul>

        </main>
        <div class="d-none d-xl-block col-xl-2 bd-toc">
        <ul id="table-of-content">
<li><a href="#toc-0">编写 TensorFlow 文档</a><ul>
<li><a href="#toc-1">关于版本的说明</a></li>
<li><a href="#toc-2">参考文档与非参考文档</a></li>
<li><a href="#toc-3">Markdown</a></li>
<li><a href="#toc-6">生成文档和预览链接</a></li>
<li><a href="#toc-7">生成 Python API 文档</a></li></ul>
</li>
<li><a href="#toc-11">只有在定义了 <code>__all__</code> 的文件中使用 <code>*</code> 导入</a><ul>
<li><a href="#toc-13">操作（op）文档样式指南</a></li>
<li><a href="#toc-19">文档字符串章节的描述</a></li></ul>
</li>
<li><a href="#toc-23">'t' 是一个形状为 [1, 2, 1, 3, 1, 1] 的张量</a><ul>
<li><a href="#toc-24">分割</a></li>
</ul>
</li>
</ul>

        </div>
    </div>
</div>
<!-- Content end-->

<!-- Footer start -->
<footer class="footer">
    <div class="container">
        <div>如果您发现本页面存在错误或可以改进，请<a href="https://github.com/xitu/tensorflow-docs/blob/zh-hans/community/documentation.md" target="_blank">点击此处</a>帮助我们改进。本页贡献者：<span id="contributors"></span></div>
        <hr/>
        <div class="text-center official-links">
            <a href="https://www.tensorflow.org"><img
                    src="https://www.tensorflow.org/_static/b1fb9a8564/images/tensorflow/lockup.png" height="20"/></a>
            <a href="https://github.com/xitu/tensorflow-docs"><img
                    src="https://assets-cdn.github.com/images/modules/logos_page/GitHub-Logo.png" height="20"></a>
            <a href="https://juejin.im"><img src="//xitu.github.io/tensorflow-docs-web/assets/imgs/logo_app_white.png" height="20"/></a>
        </div>
    </div>
</footer>
<script>
    var contributors = [{'DAA233': 'https://avatars0.githubusercontent.com/u/15101533?v=4'}, {'leviding': 'https://avatars3.githubusercontent.com/u/26959437?v=4'}]
</script>
<!-- Footer end -->
</body>
<script src="//cdn.bootcss.com/jquery/3.3.1/jquery.slim.min.js" type="text/javascript"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js" type="text/javascript"></script>
<script src="//xitu.github.io/tensorflow-docs-web/assets/js/main.js" type="text/javascript"></script>
</html>